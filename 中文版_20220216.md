**极客的互联网计算机(v1.0)**

Dfinity团队[^*]

2022年1月21日



**摘要**

智能合约是一种新的软件形式，它将彻底改变软件的编写方式、IT 系统的维护方式，以及应用程序和整个业务的构建方式。智能合约是在去中心化区块链上运行的可组合且自动化的软件拼图，这使得它们不可篡改且势不可挡。在本文中，我们将介绍互联网计算机(以下简称IC)，它在根本上是一种全新的区块链设计，可以摆脱智能合约在传统区块链上的速度、存储成本和计算能力方面的限制，释放智能合约的全部潜力。IC首次允许智能合约实现完全去中心化，从前端到后端都托管在区块链上。 IC 由一组加密协议组成，这些协议将独立运行的节点相互连接组成一个区块链集合。这些区块链托管并执行"储罐(Canister)"，即 IC上的智能合约。储罐可以存储数据，对其执行通用的计算，并提供完整的技术栈，直接为最终用户提供网络服务。计算和存储成本采用“反向GAS模型”，需要储罐开发人员将IC 的原生代币ICP兑换成cycles进行支付。ICP 代币同时也用于治理：IC由去中心化自治组织即DAO进行管理，DAO决定变更IC的网络拓扑结构和升级IC协议。

[^*]: https://dfinity.org/foundation/



# 引言

## 释放智能合约潜力

由于其独具的特性，智能合约是 Web3 的关键推动要素，也是获取Web3网络的新方式。在Web3中应用程序完全由用户控制并在去中心化的区块链之上运行。这种去中心化应用程序（以下简称dapps/dapp）通常是代币化的，这意味着项目方本身的代币被分发给用户作为参与dapps的奖励。用户可以有多种不同的参与dapps的形式，包括审核和提供内容，治理，创建和维护dapp。通常来说，用户可以在交易所购买代笔。实际上，常见的是项目方是通过出售代币为dapp 开发进行融资。最后代币还可以被用于支付dapp提供的服务或内容。在目前的区块链平台包括最流行的这些（例如以太坊），智能合约在其之上运行都会遇到诸多限制，包括较高的交易手续费和存储成本，较低的运算速度和无法向用户提供前端服务。因此，很多受欢迎的区块链并不是完全去中心化，而是中心化和去中心化结合的状态。大多数方案是将程序托管在传统的云平台中，其中一小部分功能会去调用链上的智能合约。不幸的是，这使得这些应用变得不再去中心化，令它们暴露在传统云平台托管程序的许多风险之中，例如受云平台服务商的控制和容易发生单点故障。

​		IC是一个新的运行智能合约的平台。在这里，我们使用术语“智能合约”是一个广泛意义上的概念：一种*通用的*，*不可变的*，*防篡改*的计算机程序，其在*分布式公共网络*中*自主*执行。

- *通用的*，是指智能合约这类程序是图灵完备的（即任何可计算的运算都可以用智能合约完成）。
- *不可变的*，是指一旦部署，智能合约的代码不能由一方单方面变更。[^1]
- *防篡改的*，是指程序的指令被可信地执行，并且计算的中间结果和最终结果被准确地存储和/或传输。
- *自主的*，是指智能合约被网络自动执行，不需要任何人采取任何行动。
- *分布式公共网络*，是指计算机网络可公开访问，地理上分布式，并且不受少数人或组织控制。

此外，智能合约

- 是*可组合的*，意味着他们可以彼此交互。
- 支持*代币通证*，意味着他们可以使用和交易代币。

​		对比现有的智能合约平台，IC设计上：

- 更具*成本优势*，特别是应用程序计算和存储数据的成本，只是先前平台成本的很小一部分；
- 为智能合约的交易处理提供*更高的吞吐量*和*更低的延迟*；
- 更具扩展性，特别是IC可以在本地处理无限量的智能合约数据和计算，因为它可以通过向网络中添加节点来提升容量。

​		除了提供智能合约平台之外，IC设计上是一个完整的技术堆栈，构建的系统和服务可以完全在IC上运行。特别的是，IC上的智能合约可以处理终端用户的HTTP请求，因此智能合约可以直接提供交互式的网络体验。这意味着，系统和服务的创建不需要依赖于公司的云托管服务或者私人服务器，从而以真正的端到端的方式提供智能合约的所有优势。

**实现Web3的愿景。**对于终端用户而言，访问基于IC的服务在很大程度上是透明的。他们个人数据比访问公有云或私有云的应用时更安全，但是与应用程序的交互体验是一样的。

​		然而，对于创建和管理基于IC的服务的人来说，IC消除了许多在开发和部署当前的应用程序和微服务时的成本，风险和复杂性。例如，IC平台为垄断互联网的科技巨头所推动的整合，提供了另一个选择。此外，IC安全协议可以确保消息的可靠传递，透明可追溯，以及不需要依赖于防火墙，备份设施，负载均衡服务器和故障编排就可以实现的网络弹性。

​		构建IC就是要互联网回归其开放，创新和创造性的本源——换句话说，就是*要实现Web3的愿景*。在针对几个特别的示例中，IC做了如下一些事：

- 提供互操作性，公共函数，永久APIs和无主应用程序，上述的所有特点减少了平台的风险，并鼓励创新和协作。
- 将数据自动存储于内存中，无需数据库服务器和存储管理，提升了计算效率并简化了软件的开发。
- 简化了IT组织需要集成和管理的技术堆栈，提升了运营效率。

[^1 ]:IC允许智能合约有一系列的可变更选项，包括完全不可变更到单方面可升级，以及介于两者之间的其他选项 

## IC的高度抽象

大体上，IC是一个**复制状态机(replicated state machines)**的交互网络。复制状态机在分布式系统[[Sch90]](#[Sch90])中是一个相当标准的概念，但是我们在这里仍然简单介绍下，从*状态机*的概念开始。

​		**状态机**是一种特定的计算模型。状态机维护着一个**状态**，即对应普通计算机中的主存储或是其他形式的数据存储。状态机按离散的**轮次**进行执行：每一轮中，它接受一个**输入**，对*输入*和*当前状态*应用一个**状态转换函数**，获得一个**输出**和一个**新的状态**。这一*新状态*将变成下一轮次的*当前状态*。

​		**IC**中的状态转换函数是一个**通用函数**，意味着一些存储在状态中的输入和数据可能是任意的**程序**，这些程序会作用于其他的输入和数据。因此，这样的一个状态机代表了一个通用（即图灵完备）的计算模型。

​		为了实现**容错性**，状态机可以被**复制**。**复制状态机**包含由一个**节点副本**(replicas)组成的**子网**，其中每一个节点副本运行同一个状态机的一个副本。即使某些节点副本发生故障，子网也应当继续并且正常运行。

​		子网中的每个节点副本都必须按照相同的顺序处理输入。为此，子网中的节点副本必须运行**共识协议**[[Fis83]](#[Fis83])，来确保子网中的所有节点副本按照相同的顺序处理输入。因此，每一个节点副本的内部状态将按照相同的方式随时间变更，并且每个节点副本会生成相同的输出序列。需要注意的是IC上复制状态机的输入可能是由外部用户触发的输入，也有可能是另一台复制状态机的输出。类似地，复制状态机的输出可能是直接面向外部用户的输出，也有可能是另一台复制状态机的输入。

## 故障模型

在计算机科学的这一领域，通常会考虑两种类型的节点副本故障：**宕机故障**和**拜占庭故障**。**宕机故障**发生在节点副本突然停机并且无法恢复时。**拜占庭故障**是节点副本可能以任意的方式偏离规定的协议。而且在拜占庭故障下，一个或多个节点副本可能直接处于一个恶意破坏者的控制之中，其会协调这些节点副本的行为。在这两种故障类型中，拜占庭故障潜在的破坏性更大。

​		共识协议和实现复制状态机的协议通常会假设**多少**节点副本可能发生故障以及发生**何种程度**的故障（宕机或拜占庭）。IC中假设一个给定的子网若有$n$个节点副本，那么发生故障的节点副本少于$n/3$，并且这些故障可能是拜占庭式。（需要注意的是，IC中的不同子网可能有不同的大小。）

## 通信模型

​		共识协议和执行复制状态机的协议通常也会对**通信模型**作出假设，描述了恶意方延迟节点副本间消息传递的能力。在通信模型的两个极端情况下，我们有如下的模型

- 在**同步模型**中，存在已知的有限时间限制$\delta$，因此对于发送的任意消息，它会在小于的时间内完成传递。
- 在**异步模型**中，对于发送的任意消息，恶意方可以延迟传递任意有限时间，因此对于传递消息没有时间限制；但是，每一个消息最终都必须完成传递。

​		由于IC子网中的节点副本通常分布在全球，同步通信模型非常不切实际。事实上，攻击者可以延迟诚实节点副本或是延迟诚实节点副本间的通信，来破坏协议的正确行为。这种攻击通常比控制和破坏诚实节点副本更容易实施。

​		在全球分布子网的设定下，最严谨和健壮的模型是异步模型。不幸的是，目前没有已知的共识模型在异步模型下是真正可行的（最近的异步共识协议，如[[MXC&+^16]](#[MXC16])，可以达到可观的吞吐量，但是延迟不低）。所以同其他大多数不依赖于同步通信的实用拜占庭容错系统（例如PBFT[[CL99]](#CL99), [BKM18](#BKM18), [AMN^+^20](#AMN20)）一样，IC选择了一种折衷的方案：**部分同步**通信模型[[DLS88]](#DLS88)。这样的部分同步模型可以有多种构建方式。IC使用的部分同步模型假设从大致上讲，每个子网中节点副本的通信在很短的时间间隔内是周期性同步的；此外，同步限制时间$\delta$不需要提前知晓。建立这种部分同步假设仅仅是为了确保共识协议的进行（所谓的活性）。确保共识的正确性（所谓的安全性）并不需要这种部分同步假设（消息最终传递假设也是如此），同样在IC协议栈的其他任何地方也不需要。

​		在部分同步和拜占庭故障的假设下，我们对于故障节点数量$f<n/3$的限制是最优解。

## 权限模型

最早的共识协议是**许可管理的**，也就是说构成复制状态机的节点副本是受一个中央组织管理的，其决定了哪些实体可以提供节点副本，网络的拓扑结构，并且可能还实现了某种程度中心化的公钥基础设施。许可共识机制通常效率是最高的，尽管它们避免了单点故障，但是中心化管理对于特定的应用程序是不可取的，并且这违背了蓬勃发展的Web3时代的精神。

​		最近，我们看到了无需许可的共识协议的兴起，例如Bitcoin[[Nak08]](#Nak08)，Ethereum[[But13]](#But13)和Algorand[[GHM^+^17]](#GHM17)。这些协议基于**区块链**，采用**工作量证明（以下简称PoW）**（例如Bitcoin，Ethereum2.0之前）或是**权益证明机制（以下简称PoS）**（例如Algorand，Ethereum2.0）。尽管这些协议是完全去中心化的，但是他们比许可协议效率更低。我们也需要指出，正如[[PSS17]](#PSS17)所观察到的，基于PoW机制的共识协议例如Bitcoin，在异步通信网络下并不能保证正确性（即安全性）。

​		IC的权限模型是一个**混合模型**，在拥有许可协议的效率的同时提供去中心化PoS协议的好处。这个混合模型叫做**去中心化自治组织控制网络**，（大致上讲）按如下机制工作：每个子网运行一个许可共识协议，但是由一个**去中心化自治组织（以下简称DAO）**决定哪些实体可以提供节点副本，配置网络的拓扑结构，提供公钥基础设施，并且控制节点副本部署的协议版本。IC的DAO被称为**网络神经系统（以下简称NNS）**，基于Pos，因此所有NNS的决策都由社区成员决定，社区成员的投票权由其在NNS中质押的IC原生治理代币（关于该代币的细节详见[章节1.8](#功能代币)）数量决定。通过这个基于PoS创建的治理系统，可以创建新的子网，可以在现有子网中增加或者移除节点副本，可以部署软件更新并且可以对IC进行其他调整。NNS本身是一个复制状态机，（和其他状态机一样）运行在特定的子网上，其成员资格由同一套基于PoS的治理系统决定。NNS维护一个称为注册表的数据库，跟踪IC的拓扑结构：哪些节点副本属于哪个子网，节点副本的公钥等等。（关于NNS的更多细节详见[章节1.10](#NNS的更多细节)。）

​		因此，人们看到IC的去中心化自治组织控制网络可以允许IC获得许可网络的很多实际的优势（在更有效的共识方面），同时可以维持去中心化网络的许多优势（在DAO治理下）。

​		运行IC协议的节点副本托管在地理上分布，独立运行的数据中心之上。这也增强了IC的安全性和去中心化性。

## 链钥加密技术

IC的共识协议确实使用了区块链，但它也采用了公钥加密技术，特别是电子签名：NNS维护的注册表用于将公钥绑定至节点副本及子网形成一个整体。这实现了一个独一无二的强大技术集合，我们称之为**链钥加密技术**，它有几个组成部分。

### 阈值签名

链钥加密技术的第一个组成部分是**阈值签名**：阈值签名是一个成熟的加密技术，它允许子网拥有一个公共的验证签名密钥，对应的签名私钥分成**多份**分配给子网中的节点副本，而分配保证作恶节点无法伪造任何签名，而诚实节点拥有的私钥片段可以允许子网生成符合IC策略和协议的签名。

​		这些阈值签名的一个关键应用在于

​				*一个子网的单独输出可以由另一个子网或是外部用户进行验证，验证可以简单地利用该子网（第一个子网）的公共验证签名密钥来验证电子签名实现。*	

注意子网的公共验证签名密钥可以从NNS中获取——该公共验证签名密钥在子网的生命周期中保持不变（即使子网的成员在该生命周期中可能发生改变）。这与许多不可扩展的区块链协议形成鲜明的对比，其需要验证整个区块链来验证单个输出。

​		正如我们所看到的，这些阈值签名在IC中还有许多其他应用。一个应用于让子网中的每个节点副本可以访问无法预测的伪随机数位（源于此类阈值签名）。这是共识层使用的**随机信标**和执行层使用的**随机磁带**的基础。

​		为了安全地部署阈值签名，IC采用了创新性的**分布式密钥生成**（以下简称DKG）协议，其在我们的故障和通信模型下，构建公共签名验证密钥并为每个节点副本提供对应签名私钥的一个片段。

### 链演进技术

链钥加密技术也包括一系列复杂的技术，用于随时间推移健壮和安全地维护基于区块链的复制状态机，其合起来我们称之为**链演进技术**。每个子网在包含多轮（通常大约是几百轮）的**时期**（Epoch）内运行。利用阈值签名和其他一些技术，链演技术实现了许多按时期定期执行的基本维护工作，：

**垃圾回收：**在每一周期的末尾，所有已经被处理的输入以及所有排序这些输入所需要的共识层面的消息，可以安全地从每个节点副本的内存中清除。这对防止节点副本的存储要求无限增长至关重要。这也与许多不可扩展的区块链协议形成对比，它们必须存储创世区块开始的整个区块链。

**快速转发：**如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。这也与许多不可扩展的区块链协议形成对比，它们必须处理创世区块开始的整个区块链。

**子网成员变更：**子网的成员（由NNS决定，详见[章节1.5](#权限模型)）可能会随着时间变化。这仅可能发生在时期的边界点，需要小心操作以确保一致且正确的行为。

**主动秘密转发：**我们在上面的[章节1.6.1](#阈值签名)中提到IC是如何使用链钥加密技术——具体来说，阈值签名——来进行输出验证。它基于的就是**秘密共享**，通过将一个秘密（在这里就是签名私钥）拆分成片段分别存储在节点副本中，从而避免了任何单点故障。在每个时期开始时，这些片段都会被**主动转发**。这实现了两个目标：

- 当一个子网的成员发生变动时，转发可以确保任何新成员都有适当的秘密片段，而任何不再是成员的节点副本就不再会拥有秘密的片段。

- 如果在任意一个时期，甚至每个时期都有少量的秘密片段被泄露给攻击者，这些片段也不会帮助到攻击者。

**协议升级：**如果IC协议本身需要升级，修复漏洞或是增加新功能，可以在时期开始时通过特殊协议自动完成。

## 执行模型

如前所述，IC的复制状态机可以执行任意的程序。IC中的基本计算单元叫做**储罐**，它和*进程*的概念大致相同，包含了*程序*和其*状态*（随时间变化）。

​		储罐的程序用**WebAssembly（以下简称Wasm）**进行编码，是一种用于堆栈的虚拟机的二机制指令格式。Wasm是一种开源标准[^2]。尽管它最初设计是为了实现网页端的高性能应用，但它也非常适合用于通用计算

​		IC提供了一个运行时环境，用于储罐内执行Wasm程序，并与其他储罐和外部用户通信（通过消息传递）。虽然原则上可以用任何能编译成Wasm的语言去编写储罐程序，但我们设计了一个叫做**Motoko**的语言，它与IC的操作语义十分一致。Motoko是一种强类型，*基于参与者*[^3]的编程程序，内置支持*正交持久性*[^4]和*异步消息传递*。正交持久性意味着储罐维护的内存会自动持久化（及不必写入文件）。Motoko具有许多生产力和安全特性，包括自动内存管理，泛型，类型推断，模式匹配，以及任意和固定的算术精度。

​		除了Motoko之外，IC还提供了一个消息接口定义语言和数据格式称为**Candid**，用于高级类型语言的跨语言互操作性。这使得任何两个储罐，即使是用不同的高级语言编写，也可以轻松地相互通信。

​		为了提供全面支持任何给定编程语言的储罐开发，除了该语言的Wasm编译器外，还必须提供特定的运行时支持。当前除了Motoko之外，IC还全面支持了Rust编程语言的储罐开发。

[^2]:详见https://webassembly.org/.
[^3]:详见https://en.wikipedia.org/wiki/Actor_model.
[^4]:详见https://en.wikipedia.org/wiki/Persistence_(computer_science)#Orthogonal_or_transparent_persistence.

## 功能代币

IC使用称为ICP的功能代币。该代币有如下功能：

**NNS质押：**如[章节1.5](#权限模型)所述，ICP可以用于在NNS中*质押*获得投票权，从而参与控制IC网络的DAO。在NNS中质押代币并参与NNS治理的用户还会收到*新铸造*的ICP代币作为*投票奖励*。奖励数量由NNS制定和执行的政策所决定。

**兑换Cycles：**ICP用于支付IC的使用费用。更具体来说，ICP可以兑换成**cycles**（即销毁），这些cycles可以用于支付创建储罐（详见[章节1.7](#执行模型)）和储罐所使用的资源（存储，CPU和带宽）费用。ICP兑换成cycle的比例由NNS决定。

**支付节点提供者：**ICP用于支付节点提供者——这些实体拥有和运营着计算节点，来托管构成IC的节点副本。NNS定期（当前每月一次）决定每个节点提供者应收到的*新铸造*代币并发放至其账户。根据NNS制定和执行的政策，支付代币的前提是节点提供者为IC提供可靠的服务。

## 边界节点

**边界节点**提供IC的网络边缘服务。特别是，他们提供

- 明确定义的IC入口函数
- IC的拒绝服务保护
- 从传统客户端（例如网页浏览器）无缝访问IC

为了可以从传统客户端无缝访问IC，边界节点提供了功能，将用户的标准HTTPS请求转换成指向IC容器的输入消息，随后将该输入消息路由至储罐所在子网的特定节点副本。而且，边界节点提供了改善用户体验的额外服务：缓存，负载均衡，速率限制以及传统客户端验证来自IC响应的能力。

​		储罐通过ic0.app域名上的URL链接进行标识。初始条件下，传统客户端会寻找URL链接对应的DNS记录，获取边界节点的IP地址，随后发送一个初始的HTTPS请求至该地址。边界节点返回一个基于JavaScript的“服务工作机（service worker）”，运行于传统客户端。在此之后，传统客户端和边界节点的所有交互都通过这个服务工作机完成。

​		服务工作机的一项基本任务是利用链钥加密技术（详见[章节1.6](#链钥加密技术)）验证来自IC的响应。为此，NNS公共的验证密钥被硬编码在服务工作机内。

​		边界节点本身负责将请求路由至托管特定储罐子网的节点副本。边界节点执行路由所需要的信息从NNS中获取。边界节点保管着一个可以及时响应的节点副本列表并从中随机选择一个。

​		传统客户端与边界节点间，边界节点与节点副本之间的通信安全都由TLS[^5]保证。

​		除了传统客户端外，还可以使用“IC原生”客户端与边界节点交互，其已经包含了服务工作机的逻辑，不需要向边界节点取回服务工作机程序。

​		和节点副本一样，边界节点的部署和配置由NNS控制。

[^5]: 详见 https://en.wikipedia.org/wiki/Transport_Layer_Security.

## NNS的更多细节

如[章节1.5](#权限模型)所述，NNS是一个控制IC的算法治理系统。它通过特殊的**系统子网**中的一组储罐实现。该子网和其他子网类似，但配置有所不同（例如，系统子网中的储罐不收取cycles费用）。

​		其中最重要的一些NNS容器是

- **注册表储罐**，存储着IC的配置信息，即哪些节点副本属于哪个子网，子网和节点副本的公钥等等。
- **治理储罐**，管理着IC协议如何演进的决策制定和投票。
- **账本储罐**，记录用户的ICP代币账户和相互间的交易。

### NNS的决策制定

任何人通过在所谓的**神经元**中质押ICP代币参与NNS治理。神经元的持有者可以提议关于IC应该如何改变的**提案**并投票，例如子网的拓扑结构或者协议该如何改变。神经元的投票权利是基于PoS的。直观地说，质押更多ICP的神经元投票权利更大。但是，投票权也取决于神经元的其他特征，例如愿意质押代币更长时间的神经元持有人被赋予了更大的投票权。

​		每一个提案有确定的投票期限。如果投票期结束时，参与投票的简单多数赞成该提案，并且赞成票数超过了给定的总投票权法定人数要求（现在是3%），则该提案被采纳。否则，该提案被拒绝。除此之外，任何时候只要绝对多数（超过总投票一半）赞成或反对该提案，该提案相应被采纳或拒绝。

​		如果提案被采纳，治理储罐会自动执行决策。例如，如果一个提案提议改变网络的拓扑结构并且被采纳，治理储罐将自动使用新配置更新注册表储罐。

## 正在进行中

IC的架构仍在不断演进和扩展。以下是一些即将部署的新功能：

**DAO控制储罐。**就像IC的整体配置是由NNS控制，任意的储罐也可以由其自身的DAO控制，称为服务神经系统**（以下简称SNS）**。控制储罐的DAO可以更新储罐逻辑，也可以下达特权命令让储罐执行。

**ECDSA阈值签名。**ECDSA签名[[JVM01]](#JVM01)被用于加密货币，如Bitcoin和Ethereum，以及许多其他应用程序。虽然阈值签名已经是IC中的重要组成部分，但并不是ECSDA阈值签名。而这项新特性将允许单个储罐控制ECDSA签名密钥，这些签名密钥安全地分布在托管该储罐子网的节点副本中。

**Bitcoin和Ethereum集成。**基于新的ECDSA阈值签名，这一特性将允许储罐与Bitcoin和Ethereum链交互，包括直接签名链上交易。

**HTTP集成。**此功能将允许储罐读取任意网页（IC外部）。

# 架构概述

![截屏2022-02-11 14.53.01](https://cdn.jsdelivr.net/gh/COS666/PicGo-Gallery/img/截屏2022-02-11 14.53.01.png)

<center>图1：互联网计算机协议层</center>

如图1所示，IC协议包括四层：

- P2P层（详见[第4章](# P2P层-2)）
- 共识层（详见[第5章](#共识层-2)）
- 路由层（详见[第6章](#消息路由层)）
- 执行层（详见[第7章](#执行层-2)）

链钥加密技术(chain-key crytography)在多个层都有应用，将分别在第3章和第8章中详细介绍其阈值签名(threshold signatures)和链升级(chain-evolution)技术

## P2P层

P2P层的任务在子网的共识节点中传递协议消息。协议消息包括

- 共识消息
- 外部用户发起的输入消息

P2P层基本上提供的是一个“最有效的”广播通道

​				*如果一个诚实的共识节点广播了一条消息，那么这条消息最终将会被子网中的所有诚实节点所接受。*

​		P2P层的设计目标如下：

- **资源限制.** 所有的算法都在有限的资源(内存，带宽，CPU)下运转。
- **消息优先级.** 根据特定的属性(例如类型，大小和轮次)，不同的消息将按照不同的优先级进行排序。并且这些优先级的规则可能随着时间将会改变。
- **效率.** 高吞吐量比低延迟更重要。
- **抗DOS/SPAM.** 故障节点将不会影响诚实共识节点间的相互通信

## 共识层

IC共识层的任务是对输入消息进行排序，以确保所有的共识节点按照相同的顺序处理输入消息。现在已有很多科研中的协议是为了解决这一问题。IC采用了一种全新的共识协议，本文将用概括性的语言对其进行阐述。

​		任何安全的共识协议都应当确保两个属性，大体上就是：

- **安全性：** 所有的共识节点都事实上同意相同的输入顺序
- **活性：**所有的共识节点都应当逐一更新状态

​		IC共识层的设计目标

- 极简
- 健壮：当存在个别恶意节点时，性能会柔性下降

​		如前所述，我们假设作恶节点f<n/3(即拜占庭容错)。同时，IC在部分同步网络的假设下可以确保协议的活性，而协议的安全性甚至在完全的异步网络下依然可以保证。

​		像许多的共识协议一样，IC共识协议是基于区块链。伴随着协议的进程，以创世区块为根节点的区块树将不断生长。每一个非创世区块都包含一个有效负载(payload)，由一系列输入和父块的哈希组成。诚实的共识节点对这个区块树有一致的视角：尽管每个共识节点可能对这个区块树有不同的局部视角，但是所有的共识节点看到的都是这一相同的区块树。此外，伴随着协议的进程，区块树中总会有一条最终确定区块的路径。同样地，诚实的共识节点对这一路径有一致的视角：尽管每个共识节点可能对这条路径有不同的局部视角，但是所有的共识节点看到的都是这一相同的路径。沿着这条路径的区块有效负载中的输入，是已经排序好的输入并将由IC的执行层进行处理。

​		IC的共识协议按照轮次进行处理。在轮次h中，一个或多个高度为h的区块被添加到区块树中。也就是说，在第h轮添加的区块，距离根节点的距离都是h。在每一轮中，将通过伪随机过程给每一个共识节点分配一个唯一的排名，范围是0,...,n-1的整数。这一伪随机过程使用了随机信标(Random Beacon，使用了阈值签名技术，在章节1.6.1中已经提及并将在第3章进行详细介绍)来实现。排名最低的共识节点是该轮次的主节点。当主节点是诚实节点并且网络同步时，主节点会提议一个新区块，并加入到区块树中；此外，这将会是在该轮次唯一添加到区块树的区块，并扩展最终确定区块的路径。如果主节点不是诚实节点或者网络不同步状态，其他排名更高的共识节点也可能提议新区块，并将其添加到区块树中。无论是哪种情况，协议中主节点提议的区块仍会给予最高优先级，其他提议的区块在这一轮也会被加入到区块树中去。即使协议处理多轮后没有扩展最终确定区块的路径，区块树的高度也会随着每一轮继续增长，这样的话当在第h轮最终区块确定区块路径扩展时，其长度也将达到h。这样做的好处是，即使因为故障节点或者意外的高网络延迟到导致更长的等待时间，协议的吞吐量仍可以基本保持不变。

​		共识协议依赖于电子签名在共识节点中去验证消息。为实现这一点，每一个共识节点都与签名协议的一个公钥相关联。而共识节点和公钥之间的关联关系可以从NNS维护的注册表中获取。

## 消息路由

如章节1.7中所述，IC中的基本计算单元叫做储罐。IC提供了运行环境，使得储罐中可以执行程序，并可以通过消息与其他储罐和外部用户通信。

​		共识层将输入打包进区块的有效负载中，并随着区块被确定，对应的有效负载被传入消息路由层，然后被执行层处理。执行层将随之更新状态机副本上储罐的状态并生成输出，并交由消息路由层处理。

​		我们有必要区分两种输入类型：

**入口消息：**由外部用户发起的消息

**跨子网消息：**由其他子网的储罐发起的消息

​		我们同样可以区分两种输出类型：

**入口消息响应：**对于入口消息的响应（有可能被外部用户取回）

**跨子网消息：**传输给其他子网储罐的消息

​		在收到共识层的有效负载后，其中的输入消息将会分配到不同输入队列中。对于每个子网上的每一个容器C而言，有这些输入队列：一个队列负责向容器C发起的入口消息，对于每一个与容器C通信的容器C'都会有一个单独的队列，负责从容器C'向容器C发起的跨子网消息。

​		在每一轮中，执行层会处理输入队列中的一部分消息，并更新状态机的副本状态(replicated state)，将输出消息放入队列中。对于每个子网上的每一个容器C而言，有这些输出队列：对于每一个与容器C通信的容器C'都会有一个单独的队列，负责从容器C向容器C'发起的跨子网消息。消息路由层会提取输出队列中的消息，将其放置到子网间信息流(subnet-to-subnet streams)中，由跨子网传输协议(crossnet transfer protocol)进行处理，跨子网传输协议的主要任务就是传输这些消息给其他子网。

​		除了这些输出队列之外，还有一个入口消息历史的数据结构。一旦一个入口消息被储罐处理后，对该入口消息的响应将会在这一数据结构中进行记录。此时，发起该入口消息的外部用户就可以获取对应的响应（注意入口消息历史不会保留所有入口消息的历史记录）。

​		需要注意的是，节点副本的状态包括储罐的状态以及“系统状态”。“系统状态”包括上述提及的队列，信息流以及入口消息历史。因此，消息路由层和执行层同时负责更新和维护子网的副本状态。此时就必须确保以完全确定的方式更新这一状态，这样所有共识节点保持完全相同的状态。

​		另外需要注意的是，共识层和消息路由层以及执行层是解耦的，也就是说传入有效负载之前，共识区块链中的任何分叉都已经被解决了。事实上，共识层允许提前运行，并不需要和消息路由层保持完全一致的进度。

### 单轮验证状态(Per-round certified state)

在每一轮中，子网的一部分状态会被验证。单轮验证状态采用链钥加密技术进行验证。除了一些别的之外，给定轮次中的验证状态包括

- 最近添加到子网间信息流中的跨子网消息
- 其他元数据，包括入口消息历史的数据结构

单轮验证状态利用了阈值签名技术验证（详见章节1.6.1）。在IC中单轮验证状态被用于如下几个方面：

- **输出验证.** 跨子网消息和入口消息响应都使用单轮验证状态进行验证。
- **防止和检测不确定性.**共识层保证了每个共识节点按相同的顺序处理输入消息。因为每个共识节点确定性得处理消息，应当会得到相同的状态。但是IC额外设计了一层确保健壮性，来防止和检测任何意外的不确定性计算的发生。单轮验证状态是该机制中的其中一环。
- **协调共识层.** 单轮验证状态还通过两种方式来协调执行层和共识层：
	- 如果共识层运行快于执行层（进度由上一轮验证状态决定），共识层会被“降速”。
	- 共识层的输入必须经过特定的有效性验证，这些验证取决于所有共识节点已达成共识的验证状态。

### 查询调用(query calls)和更新调用(update calls)

正如我们之前所阐述的，所有的入口消息必须经过共识，才能被子网的所有共识节点按相同的顺序进行处理。但是，针对那些处理时不会变更状态的入口消息，可以进行一项重要的优化。这些不会变更状态的入口消息即查询调用，相对地，其他入口消息被称为更新调用。查询调用允许读取和可能更新一个储罐的状态，但是任何对该储罐的状态更新都不会提交到副本状态中。因此，一个查询调用可以一个单独的共识节点进行处理，而不需要进入共识。这大大缩短了获取查询调用的响应时间。

​		一般而言，对查询调用的响应不会记录在入口消息历史的数据结构中，因此也不可以用之前的单轮验证状态进行验证。然而，IC使储罐可以存储数据（在处理更新调用时）在特殊的验证变量中(certified variables)，可以利用这一机制验证数据的有效性；这样的话，查询调用可以返回值并存储在一个验证变量中，仍然可以被验证。

### 外部用户认证(External user authentication)

入口消息和跨子网消息的一个主要区别在于用于验证消息的机制。链钥加密技术用于验证跨子网消息，另一个不同的机制用于外部用户发起的入口消息。

​		IC中没有外部用户的中央注册表。相反，外部用户通过一串公钥哈希作为用户标识符来向储罐来标识自己。用户自己持有对应的签名密钥，用来签署入口消息。签名和公钥会随着入口消息一起发送。IC将自动验证签名并传递用户标识符给到对应的储罐。随后该储罐根据用户标识符和入口消息中指定操作的其他参数，批准请求的操作。

​		新用户在首次与IC交互时会生成密钥对并获取他们的用户标识符。老用户根据存储在用户端的私钥进行验证。用户还可以用签名委托的方式，将多个密钥对关联到一个用户身份上。这很有用，因为它允许用户可以在多个设备使用上同一个用户身份。

## 执行层

执行层一次处理一个输入消息。这一输入消息取自输入消息队列，并定向到指定的储罐。根据次输入消息和该储罐的状态，执行层环境将更新储罐的状态，另外将消息加入输出队列并更新入口消息历史（可能包括对更早的入口消息的响应）。

​		每个子网都可以访问分布式伪随机发生器(PRG)。二进制伪随机数的种子是被称为随机磁带(Random Tape)(参见章节1.6.1，详见第3章)的阈值签名。共识协议的每一轮都会有一个不同的随机磁带。

​		随机磁带的基本特性有

1. 在区块高度为h的区块被任意诚实节点确认之前，区块高度h+1的随机磁带是不可预测的。
2. 在区块高度为h+1的区块被任意诚实节点确认的时间点前，共识节点已经有构建区块高度h+1的随机磁带的所有要素

​		例如在h轮时，子网为获得二进制伪随机数，需要向执行层发起“系统请求”。系统随后将用高度h+1的随机磁带进行响应。根据上述的特性(1)，协议保证在子网发送请求时，请求的二进制伪随机数不可预测。根据上述的特性(2)，请求的二进制伪随机数通常会在下一个区块被确认时可用。

## 组合在一起

我们追踪一个用户请求在IC上的典型流程。

1. 用户通过用户端向边界节点（详见章节1.9）发送对于容器C的请求消息M，边界节点将消息M发送给托管着容器C的子网共识节点。

2. 接收到消息M后，该共识节点通过P2P层（详见章节2.1）向子网中的所有共识节点广播消息M。

3. 在接收到消息M的情况下，共识层下一轮的主节点（详见章节2.2）会将消息M和其他输入一同打包进其提议的区块B。

4. 一段时间之后，区块B被最终确认，其有效负载被发送至消息路由层（详见章节2.3）进行处理。需要注意的是，P2P层同样用于共识协议去确认区块。

5. 消息路由层会将消息放置在容器C的输入消息队列中。

6. 一段时间之后，执行层（详见章节2.4）会处理消息M，并更新容器C的内部状态。

	在一些情况下，容器C能够计算对于请求消息M的响应R。在这种情况下，响应R会被记录在入口消息的数据结构中。

	在其它情况下，处理请求消息M需要向别的储罐调用请求。在这个例子中，我们假设为处理请求消息M，容器C需要向另一个子网的另一个容器C'调用请求M'。这第二个请求M'会被放置在容器C的输出队列中，然后接下去的几步将被执行。

7. 一段时间之后，消息路由层会将调用请求M'移动到合适的跨子网信息流中，最终将会被传输到托管容器C'的子网。

8. 在第二个子网中，获取来自第一个子网的请求M'后，其会通过共识层和消息路由，最终由执行层进行处理。第二个子网的执行层会更新容器C'的内部状态，然后生成对于请求M'的响应R'。响应R'会进入容器C'的输出队列，最终放置在跨子网信息流中被传输回第一个子网。

9. 回到第一个子网，获取来自第二个子网的响应R'后，其会通过共识层和消息路由，最终由执行层进行处理。第一个子网的执行层会更新容器C的内部状态，然后生成对于原始请求M的响应R。这一响应R会被记录在入口消息的数据结构中。

​		无论是哪条执行路径，对于请求消息M的响应R，最终会被记录在托管容器C的子网的入口消息历史数据结构中。为了获取这一响应结构，用户端必须执行“查询调用”（详见章节2.3.2）。就像在章节2.3.1中所阐述的，这一响应可以被链钥加密技术（具体来说，使用的是阈值签名技术）进行验证。用户端执行的这一验证逻辑本身（即阈值签名认证），可以通过最初从边界节点获取的服务进行执行。



# 链钥加密技术I：阈值签名

IC的链钥加密技术的一个关键组成部分是阈值签名方案[[Des87]](#Des87)。IC在多处应用了阈值签名。假设子网中的节点副本数量为$n$，故障节点数量上限为$f$。

- 共识层使用$(f+1)/n$的阈值签名来实现*随机信标*（详见[章节5.5](#)）。
- 执行层使用$(f+1)/n$的阈值签名来实现*随机磁带*，用于向储罐提供不可预测的伪随机数（详见[章节7.1](#)）。
- 执行层使用$(n-f)/n$的阈值签名来*验证复制状态*。这既用于验证子网的输出（详见[章节6.1](#)），也用于实现IC*链演进技术*中的*快速转发*功能。（详见[章节8.2](#)）

对于前两个应用（随机信标和随机磁带），阈值签名必须是唯一的，即给定公钥和消息，仅有一个有效签名。因为我们使用签名作为随机数生成器，所有计算该阈值签名的副本节点必须对同样的种子达成共识。

## BLS阈值签名

我们基于BLS签名方案实现了阈值签名，使得调整阈值设定十分简单。

​		普通的BLS签名方案利用两个质数阶均为$q$的群$\mathbb{G}$和$\mathbb{G}'$。我们假设群$\mathbb{G}$通过基准点$g\in\mathbb{G}$生成，群$\mathbb{G}'$通过基准点$g'\in\mathbb{G}'$生成。我们同样假设一个哈希函数$H_{\mathbb{G}'}$可以将其输入映射到群$\mathbb{G}'$（一个随机预言机模型）。签名私钥元素$x\in\mathbb{Z}_q$，公共验证密钥$V$:= $g^x\in\mathbb{G}$。

​		无阈值的设定下，为对消息$m$签名，签名人计算$h'\leftarrow H_{\mathbb{G}'}(m)\in\mathbb{G'}$，然后计算签名$\sigma$:= $(h')^x\in\mathbb{G}$。为验证签名是否有效，必须检验$log_{h'}\sigma$是否等于$log_gV$。为了有效执行检验，BLS方案在群$\mathbb{G}$和$\mathbb{G}'$上使用了**配对**的概念，这是一种特殊的代数工具，当群$\mathbb{G}$和$\mathbb{G}'$是特殊类型的**椭圆曲线**时可用。我们无法在这里详细介绍配对和椭圆曲线。更多细节详见[[BLS01]](#BLS01)。BLS签名具有签名唯一这一良好的特性（如上所述）。

​		在$t/n$的阈值设定下，我们有$n$个节点副本，其中任意$t$个都可以用于生成消息的签名。

更具体来看，每个节点副本$P_j$私人持有签名密钥$x\in\mathbb{Z}_q$的一个片段$x_j\in\mathbb{Z}_q$，而群元素$V_j$:=$g^{x_j}$公开可用。密钥片段$(x_1,...,x_n)$是$x$的$t/n$秘密共享。

​		给定消息$m$，节点副本$p_j$可以生成**签名片段**

​																	$\sigma_j=(h')^{x_j}\in\mathbb{G}'$

其中同之前一样，$h':=H_{\mathbb{G}'}(m)\in\mathbb{G'}$。为了验证这样的签名片段是否有效，必须必须检验$log_{h'}\sigma_j$是否等于$log_gV_j$。如上所述，这可以通过配对来完成——事实上，这和用公钥$V_j$验证普通BLS签名有效性完全一样。

​		我们的阈值签名方案满足如下的**重构特性：**

> *给定消息$m$的任意$t$个有效签名片段$\sigma_j$的集合，我们可以很快计算出公共验证密钥下，消息m的有效BLS签名$\sigma$。*
>
> *事实上，$\sigma$可以按如下公式计算*
>
> ​																	$$\displaystyle \sigma\leftarrow\prod_{j}\sigma^{\lambda_j}_j$$                                        <a name="GS2"> </a>   <a name="GS1"> </a>               	(1)
>
> *其中，$\lambda_j$可以根据签名该消息m的t个节点副本的索引，很快计算出来。*

​		此方案在$\mathbb{G}$的合理难度假设下，将$H_{\mathbb{G}'}$建模成随机预言机，可以满足如下的**安全性**：

> *假设最多有$f$个节点副本被恶意对手破坏。它也无法计算消息的有效签名，除非他获取了至少$t-f$个诚实节点副本对该消息的签名片段。*

## 分布式密钥分发

为了实现BLS阈值签名，我们需要一种分发签名私钥给节点副本的方法。一种实现方法是让一个**可信方**直接计算所有这些私钥片段并分发给所有的节点副本。不幸的是，这可能会造成单点故障。相反，我们使用了**分布式密钥生成（以下简称DKG）协议**，它本质上允许节点副本在安全的分布式协议下，执行此类可信方的逻辑。

​		我们概述了当前实现的协议的顶层思想。推荐读者阅读[[Gro21]](#Gro21)了解更多细节。我们使用的DKG本质上是非交互式的。它有两个基本组成部分：

- **公开可验证秘密共享（以下简称PVSS）**方案，和
- **共识**协议

尽管任何共识协议都适用，但毫无疑问我们使用了[第5章](#共识层-2)（也可见[第八章](#链钥加密技术Ⅱ：链演进技术)）中的协议。

## 假设

所做的基本假设和[第一章](#引言)中所概述的一致：

- 异步通信，和
- $f<n/3$

我们仅仅（在[章节5.1](#假设-2)中）间接地使用了*部分*同步假设，来确保共识协议的活性。

​		对于一个t/n的阈值签名方案，我们还假设

​																			$f<t<n-f$

这（除了其他方面外）确保了（1）故障节点副本无法有效签名，和（2）诚实的节点副本可以有效签名。

​		我们还假设每个节点副本和一些公钥相关联，其中每个节点持有这些公钥的对应私钥。一个公钥是签名密钥（同[章节5.4](#公钥)中一样）。另一个公钥是实现PVSS方案的特殊公钥加密方案的公共加密密钥（详细方案如下）。

## PVSS方案

如上所述，假设通过基准点$g\in\mathbb{G}$生成质数阶为q的群$\mathbb{G}$。假设$s\in\mathbb{Z}_q$是私钥。回想一下，阈值结构为$t/n$情况下，密钥s的Shamir密钥共享的是向量$(s_1,...,s_n)\in\mathbb{G}$，其中

​													$s_j:=a(j)\ \ (j=1,...,n)$

而

​								$a(x):=a_0+a_1x+...+a_{t-1}x^{t-1}\in\mathbb{Z}_q[x]$

是次数小于$t$的多项式，其中$a_0:=s$。该类密钥共享方案的关键属性是

- 根据$t$个$s_j$的集合，我们可以有效计算密钥$s=a_0=a(0)$，和
- 如果从$\mathbb{Z}_q$中一致且独立得抽取$a_1,...,a_{t-1}$，任意少于$t$个元素的集合都无法披露密钥$s$的任何信息。

在更高层面上，PVSS方案允许节点副本$P_i$，被称为**处理员**，进行密钥共享并计算称为**交易**的对象，其中包括

- 群元素的向量$(A_0,...,A_{t-1})$，其中$A_k:=g^{a_k}$对于$k=0,...,t-1$，
- 密文向量$(c_1,...,c_n)$，其中$c_j$是$P_j$的公共验证密钥下对$s_j$的加密，
- 非交互式的零知识证明$\pi$，证明每个节点副本$c_j$确实加密了密钥片段——更准确地说，每个节点副本$c_j$解密的值满足

​															$\displaystyle g^{s_j}=\prod^{t-1}_{k=0}A_k^{j^k}=g^{a(j)}$                                                <a name="GS2"> </a>  <a name="GS2"> </a>          (2)

​		我们注意到，为了确保DKG协议的整体安全性，PVSS方案必须提供适当级别的所选密文安全性。具体来说，处理员必须将其身份作为关联数据嵌入交易，即使是选择密文攻击中，恶意方可以用与创建交易无关的关联数据，解密任意交易时，并且加密的共享片段必须要保持隐匿。

​		如果不考虑效率问题，实现PVSS方案很容易。方案中利用类似ElGamal的加密方案，对每个$s_j$逐位加密，然后对公式[（2）](#GS2)使用标准的非交互式零知识证明，该证明基于对适用的Sigma协议[(详见[CDS94])](#CDS94)应用标准的Fiat-Shamir转换[(详见[FS86])](#FS86)实现。尽管这是一个多项式时间的方案，但是并不实用。然而，有很多可能的方法来优化这个类型的方案。关于IC中使用的高度优化的PVSS方案，详见[[Gro21]](#Gro21)。

## 基础DKG协议

使用PVSS方案和共识协议，基础的DKG协议十分简单。

1. 每个节点副本向其他节点副本广播关于随机密钥的**签名交易**。

	这样的签名交易包括一个交易主体，节点副本身份以及节点副本公钥下对该交易的签名。

	如果语法格式正确，签名和非交互式的零知识证明有效，那么这样的签名交易是有效的。

2. 利用共识协议，节点副本对$f+1$的有效签名交易集合$S$达成一致意见。

3. 假设集合$S$中的第i个交易包含群元素向量$(A_{i,0},...,A_{i,t-1})$和密文向量$(c_{i,1},...,c_{i,n})$。

	然后阈值签名方案的公共验证密钥是

	​													       $\displaystyle V:=\prod_iA_{i,0}$   

	注意，签名私钥被隐式定义

	​														  $x:=log_gV$

	节点副本$P_j$的签名私钥x的片段为

	​														  $\displaystyle x_j:=\sum_i s_{i,j}$

	其中$s_{ij}$是$p_j$的解密私钥下对$c_{i,j}$的解密。

	节点副本$P_j$的公共验证密钥是

	​														  $\displaystyle V_j:=\prod_i \prod^{t-1}_{k=0}A_{i,k}^{j^k}=g^{x_j}$  

​		需要注意的是，密钥片段$x_j$包含$x$的阈值结构为$t/n$的Shami密钥共享。因此，公式[（1）](#GS1)中出现的只是拉格朗日插值系数。这证实了[章节3.1](#BLS阈值签名)中提到的*重构特性*。至于中[章节3.1](#BLS阈值签名)提及的安全性，可以证明如下。在$H_{\mathbb{G}'}$建模成随机预言机的情况下，假设PVSS方案是安全的，群$\mathbb{G}$和$\mathbb{G}'$（通过配对）满足**one-more Diffie-Hellman**的特定类型的难度假设，即不存在有效的对手方，有概率赢得下面的博弈：

> ​		*挑战者随机选择$\mu_1,...,\mu_k\in\mathbb{Z}_q$和$v_1,...,v_l\in\mathbb{Z}_q$，将给到对手方$\{g^{\mu_i}\}^k_{i=1}$和$\{(g')^{v_j}\}^l_{j=1}$*
>
> ​		*对手方向挑战者发起一系列查询请求，每一个请求都是$\{k_{i,j}\}_{i,j}$形式的向量，挑战者回应对应的*
>
> ​															$\displaystyle \prod_{i,j}((g')^{\mu_iv_i})^{k_{i,j}}$   
>
> ​		*为结束这场博弈，对手方输出向量$\{\lambda_{i,j}\}_{i,j}$和群元素$h'\in\mathbb{G}'$，并将赢得博弈如果*
>
> ​															$\displaystyle h'=\prod_{i,j}((g')^{\mu_iv_i})^{\lambda_{i,j}}$
>
> ​		*并且输出向量$\{\lambda_{i,j}\}_{i,j}$不是请求向量的线性组合。*		

​		尽管当$t>f+1$的情况下，需要这类one-more Diffie-Hellman假设，但是当$t=f+1$的情况下，可以采用较弱的假设(即所谓的co-CDH假设，普通BLS签名方案的安全性即基于此)。

## 转发协议

基础DKG协议可以很容易地修改，因此不需要创建一个新的随机密钥$x$的共享，而是创建一个先前共享密钥的新随机共享。

- 修改基础协议的第1步，以便每个节点可以广播已有共享片段的签名交易
- 修改第2步，以便就$t$个有效签名的集合达成一致。此外，每个交易都经验证以确保是现有共享片段的交易（这意味着在第$i$个交易中$A_{i,0}$的值应当等于$V_i$的旧值）。
- 第3步中，通过计算$i$个拉格朗日插值系数的和（和乘积），等于新的$x_j$（和$V_j$）。

# P2P层

P2P层的任务是在子网的节点副本中传递协议消息。这些协议消息包括

- 用于实现共识的消息，例如，区块提案（block proposals），公证（notarizations）等（详见[第5章](#共识层-2)）
- 输入消息（详见[第6章](#消息路由层)）

基本上，P2P协议提供的服务是“尽力而为（best effort）”的广播通道：

> 如果一个诚实节点副本广播一条消息，那么这条消息最终会被子网中的所有诚实节点副本接受到。

​		协议的设计目标包括以下内容：

- **资源限制.** 所有的算法都在有限的资源(内存，带宽，CPU)下运转。
- **消息优先级.** 根据特定的属性(例如类型，大小和轮次)，不同的消息将按照不同的优先级进行排序。并且这些优先级的规则可能随着时间将会改变。
- **效率.** 高吞吐量比低延迟更重要。
- **抗DOS/SPAM.** 故障节点将不会影响诚实共识节点间的相互通信

​		注意到，在共识协议中，一些消息，尤其是区块提案（会非常大），将被所有节点副本反复广播。这对确保协议的正确运作是必须的。但是，如果单纯这样实现，将会是巨大的资源浪费。为了避免节点副本广播相同的消息，P2P层使用了**公告-请求-传递**的机制。它不会直接传递（数据量大的）消息，而是广播该消息的（数据量小的）**公告**：如果节点副本收到这样的公告并且没有收到过对应的消息，将认定该消息是重要的，节点副本将**请求**该消息的**传递**。这个策略以更高延迟的代价，降低了带宽使用量。对于小消息，牺牲延迟追求带宽是不值得的，可以直接发送消息而不是公告。

​		对于相对较小的子网，希望广播消息的节点副本，会将公告发送至子网中的所有节点副本。对于较大的子网，**公告-请求-传递**机制可以在一个**覆盖网络**上运行。覆盖网络是一个连接的无向图，子网内的节点副本组成其顶点。如果图中有一条边连接两个节点副本，那他们是**对等节点**，节点副本仅和它的对等节点通信。因此，当节点副本希望广播消息时，他将该消息的公告发送给它的对等节点。这些对等节点在收到公告后，可能会请求消息的传递，如果满足特定条件，这些对等节点会将该消息的公告发送给他们的对等节点。这本质上是一个**散播网络（gossip network）**。这个策略用比先前更高的延迟代价，再次降低了带宽使用量。

# 共识层

## 假设

## 协议概览

## 额外特性

## 公钥

## 随机信标

## 区块生成

## 公证

## 最终确认

## 延迟函数

## 例子

## 组合在一起

### 随机信标细节

### 区块生成细节

### 公证细节

### 增长证明

### 安全性证明

### 活性证明

## 其他

### 增长延迟

### 本地调整延迟函数

### 公正性

# 消息路由层

## 每轮验证状态

## 查询请求和更新请求

## 外部用户验证

# 执行层

## 随机磁带

# 链钥加密技术Ⅱ：链演进技术

如[章节1.6.2](#链演进技术)所述，链钥加密技术包括一系列复杂的技术，用于随时间推移健壮和安全地维护基于区块链的复制状态机，其合起来我们称之为**链演进技术**。每个子网在包含多轮（通常大约是几百轮）的**时期**（Epoch）内运行。链演技术实现了许多按时期定期执行的基本维护工作：*垃圾回收，快速转发，子网成员变更，主动秘密转发和协议升级。*

​		链演进技术包含两个基本组成部分：**摘要块**和**追赶包（以下简称CUPs）**。

## 摘要块

每个时期的第一个区块是摘要块。摘要块包含特殊数据，用于管理不同阈值签名方案的密钥片段（详见[第3章](#链钥加密技术I：阈值签名)）。其中有两种阈值签名方案：

- 阈值结构为$f+1/n$的方案中，每个时期生成新的签名密钥；
- 阈值结构为$n-f/n$的方案中，每个时期重新共享一次签名密钥。

阈值低的方案用于*随机信标*和*随机磁带*，而阈值高的方案用于验证子网的复制状态。

​		回想一下，DKG协议（详见[章节3.5](#基础DKG协议)）要求，对于每个签名密钥，有一组交易，而每个节点副本可以根据这组交易，非交互式得获取它的签名密钥片段。

​		再回想一下，除了别的之外，NNS还维护着决定子网成员的**注册表**（详见[章节1.5](#权限模型)）。注册表（以及子网成员）会随时间改变。因此，子网必须对在不同时间和不同目的下，使用的**注册表版本**达成一致。这一信息也存储在摘要块中。

​		时期$i$的摘要块包括如下数据字段。

- *当前注册表版本（currentRegistryVersion）。*这个注册表版本将决定时期$i$中的共识委员会——所有共识层的任务（生成区块，公证，最终确认）都由这个委员会执行。

- *下一个注册表版本（nextRegistryVersion）。*在每一轮共识中，区块生成者会将其知道的最新注册表版本（不得早于提议的区块的构建时间）包含在区块提案内。这确保了时期$i$中的*下一注册表版本*是最新值。

	时期$i$中的当前注册表版本值设置为时期$i-1$中的下一个注册表版本值。

- *当前交易集（currentDealingSets）。*这个交易集用于决定时期i中签名消息的阈值签名密钥。

	正如我们所看到的，时期$i$中的阈值签名委员会是时期$i-1$中的共识委员会。

- *下一个交易集（nextDealingSets）。*这个字段收集和存储时期$i-1$中*收集到*的交易[^7]。时期$i$中的*当前交易集*的值将被设置为时期$i-1$中下一个交易集的值（本身包含时期$i-2$中收集到的交易）。

- *收集交易参数（collectDealingParams）。*这个字段描述了时期i中需要*收集*的交易集的参数。时期$i$中，区块生成者会将经这些参数验证有效的交易，放进提议的区块内。

	这些交易的*接受委员会*基于时期$i$的摘要块的*下一个注册表版本*。

	对于低阈值的签名方案，时期$i$中的*交易委员会*是时期$i$中的共识委员会。

	对于高阈值的签名方案，密钥片段的共享是基于时期i中的*下一个交易集*。因此时期$i$中的*交易委员会*是时期$i-1$中的*接受委员会*，也是时期$i$中的*共识委员会*。

	还要注意的是，时期$i$中的阈值签名委员会是时期$i-2$中的接受委员会，其是时期$i-1$中的共识委员会。

​		时期$i$中的共识协议依赖于时期$i$中的*当前注册表版本*和*当前交易集* ——具体来说，共识委员会本身基于*当前注册表版本*，共识中的随机信标基于*当前交易集*。此外，同其他区块一样，在时期$i$开始的时候可能会有多个经过公证的摘要块，并且这种歧义需要在时期$i$中经过共识来解决。这种看似循环的问题的解决办法是，保证时期i-1开始时的摘要块，在时期i开始前已经最终确认，因为新的摘要块的相关值，是直接从老的摘要块复制而来。这实际上是一个*隐含的同步假设*，但它也更是一个学术假设。事实上，因为章节5.12.2中讨论的确保活性的“共识节流（consensus throttling）”，也因为时期的长度很长，下面的情况本质上不可能发生：早在共识到达时期i-1结束之前，时期i-1的摘要块没有被最终确认，公证延迟函数将增长到非常之大，因此最终确定性需要的部分同步假设（实际上）肯定会（基本）满足[^8]。

[^7]:我们省略的一个细节是，如果在时期$i-1$中，我们没有收集到所有需要的交易，那么作为备选方案，时期$i$中的下一交易集的值将被设置为时期$i$中的当前交易集的值。如果这种情况发生，那么协议将酌情使用之前的交易委员会和阈值签名委员会。
[^8]: 另外需要注意的是，时期$i$中收集的交易取决于时期i的摘要块，具体来说，就是下一个交易集和下一个注册表版本。因此在时期$i$的摘要块被最终确定之前，这些交易不应当生成且不能被验证。

## CUPs

在阐述CUP之前，我们首先需要指出随机信标的一个细节：每一轮的随机信标取决于前一轮的随机信标。它不是CUP的基本特性，但是影响了CUP的设计。

​		**CUP**是一种特殊的（不在区块链上的）消息，它（基本上）拥有一个节点副本在不知道先前时期任何信息下，在时期开始时工作时所需的一切。它包含如下的数据字段：

- **整个**复制状态的默克尔哈希树的根（与章节1.6中的每轮验证的部分状态不同）。
- 时期的摘要块。
- 时期第一轮的随机信标。
- 子网对上述字段的$(n-f)/n$的阈值签名。

为生成给定时期的CUP，节点副本必须等到该时期的摘要块已经被最终确认，并且对应的每轮状态经过验证。如前所述，*整个*复制状态必须经哈希函数处理为一个默克尔树——尽管有很多技术用于加快这一过程，这个成本代价仍然非常大，这也是为什么每个时期仅处理一次。因为CUP仅包含这个默克尔树的根，因此我们使用了一个**状态同步**子协议，允许节点副本从对等节点中提取它所需要的任何状态——同样地，我们用了很多技术来加快这一过程，它的成本代价仍然很大。因为我们对CUP使用了高阈值签名，因此可以保证在任何时期只有一个有效的CUP，而且可以从很多对等节点中提取状态。

## 链演进技术实现

**垃圾回收：**因为CUP包含特定时期的信息，因此每个节点副本可以安全地清除该时期前所有已处理的输入，以及对这些输入排序的共识层消息。

**快速转发：**如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。该节点副本可以通过获取最新CUP做到。利用从CUP中包含的摘要块和随机信标，以及来自其他节点副本的（还没有被清除的）共识消息，该节点副本可以从相应时期的起始点开始，向前运行共识协议。该节点也可以使用状态同步子协议来获取对应时期开始时的复制状态，这样它也可以开始处理共识层产生的输入。

图5描绘了快速转发。此处，我们假设需要一个需要追赶的节点副本处于时期起始点，（比方说）区块高度为101，有一个CUP。这个CUP包含了区块高度101的复制状态的默克尔树的根，区块高度为101的摘要块和区块高度为101的随机信标。该节点会使用状态同步子协议，从它的对等节点中获取区块高度101的所有复制状态，并用CUP中的默克尔树来验证此状态。

![截屏2022-02-13 23.36.57](https://cdn.jsdelivr.net/gh/COS666/PicGo-Gallery/img/截屏2022-02-13 23.36.57.png)

<center>图5：快速转发</center>

在获取到该状态后，节点副本可以参与到协议之中，从对等节点中获取高度为102，103等等的区块（以及其他和共识相关的消息），并更新其复制状态的副本。如果其对等节点已经确认了更高高度的区块，该节点副本将尽快处理（以及公证和最终确认）这些从对等节点获取的已最终确认区块（以执行层所允许的最快速度）。

**子网成员变更：**我们已经讨论过特定时期内，如何使用摘要块来加密，使用哪个版本的注册表以及它如何决定子网成员，更具体来说，是各种任务的委员会成员。需要注意的是，即使一个节点副本从一个子网中移除，（如果可能的话）它应当多履行一个时期的分配到的委员会职责。

**主动秘密转发：**我们已经讨论过了，如何使用摘要块生成和转发签名密钥。如有必要，需要的摘要块也可以从CUP中获取。

**协议升级：**CUP也用于协议升级。协议升级由NNS发起（详见[章节1.5](#权限模型)）。不考虑所有细节，基本细节如下：

- 当需要安装新版本的协议时，时期开始时的摘要块会指出这一点；
- 所有运行老版本协议的节点副本将继续运行共识协议直到最终确认摘要块并创建对应的CUP；然而，他们只会创建空区块并不会将任何有效负载传递给消息路由层和执行层；
- 安装新版本的协议后，运行新版本共识协议的节点副本，将从上述的CUP开始恢复运行完整的协议。





**参考文献**

[AMN+20]<a name="AMN20"> </a>I. Abraham, D. Malkhi, K. Nayak, L. Ren, and M. Yin. Sync HotStuff: Simple and Practical Synchronous State Machine Replication. In 2020 IEEE Sympo- sium on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020, pages 106–118. IEEE, 2020.



[BGLS03]<a name="BGLS03"> </a>D. Boneh, C. Gentry, B. Lynn, and H. Shacham. Aggregate and Verifiably Encrypted Signatures from Bilinear Maps. In E. Biham, editor, Advances in Cryptology - EUROCRYPT 2003, International Conference on the Theory and Applications of Cryptographic Techniques, Warsaw, Poland, May 4-8, 2003, Proceedings, volume 2656 of Lecture Notes in Computer Science, pages 416– 432. Springer, 2003.



[BKM18]<a name="[BKM18]"> </a>E. Buchman, J. Kwon, and Z. Milosevic. The latest gossip on BFT consensus, 2018. arXiv:1807.04938, http://arxiv.org/abs/1807.04938.



[BLS01]<a name="BLS01"> </a>D. Boneh, B. Lynn, and H. Shacham. Short Signatures from the Weil Pairing. In C. Boyd, editor, Advances in Cryptology - ASIACRYPT 2001, 7th Interna- tional Conference on the Theory and Application of Cryptology and Information Security, Gold Coast, Australia, December 9-13, 2001, Proceedings, volume 2248 of Lecture Notes in Computer Science, pages 514–532. Springer, 2001.



[But13]<a name="But13"> </a>V. Buterin. Ethereum whitepaper, 2013. https://ethereum.org/en/ whitepaper/.



[CDH+21]<a name="CDH21"> </a>J. Camenisch, M. Drijvers, T. Hanke, Y.-A. Pignolet, V. Shoup, and D. Williams. Internet Computer Consensus. Cryptology ePrint Archive, Report 2021/632, 2021. https://ia.cr/2021/632.



[CDS94]<a name="CDS94"> </a>R. Cramer, I. Damg ̊ard, and B. Schoenmakers. Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols. In Advances in Cryptology - CRYPTO ’94, 14th Annual International Cryptology Conference, Santa Bar- bara, California, USA, August 21-25, 1994, Proceedings, volume 839 of Lecture Notes in Computer Science, pages 174–187. Springer, 1994.



[CL99]<a name="[CL99]"> </a>M. Castro and B. Liskov. Practical Byzantine Fault Tolerance. In M. I. Seltzer and P. J. Leach, editors, Proceedings of the Third USENIX Symposium on Op- erating Systems Design and Implementation (OSDI), New Orleans, Louisiana, USA, February 22-25, 1999, pages 173–186. USENIX Association, 1999.



[CWA+09]<a name="CWA09"> </a>A. Clement, E. L. Wong, L. Alvisi, M. Dahlin, and M. Marchetti. Making Byzantine Fault Tolerant Systems Tolerate Byzantine Faults. In J. Rexford and E. G. Sirer, editors, Proceedings of the 6th USENIX Symposium on Networked Systems Design and Implementation, NSDI 2009, April 22-24, 2009, Boston, MA, USA, pages 153–168. USENIX Association, 2009. http://www.usenix. org/events/nsdi09/tech/full_papers/clement/clement.pdf.



[Des87]<a name="Des87"> </a>Y. Desmedt. Society and Group Oriented Cryptography: A New Concept. In C. Pomerance, editor, Advances in Cryptology - CRYPTO ’87, A Conference on the Theory and Applications of Cryptographic Techniques, Santa Barbara, California, USA, August 16-20, 1987, Proceedings, volume 293 of Lecture Notes in Computer Science, pages 120–127. Springer, 1987.



[DLS88]<a name="DLS88"> </a>C. Dwork, N. A. Lynch, and L. J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323, 1988.



[Fis83]<a name="[Sch90]"> </a><a name="[Fis83]"> </a>M. J. Fischer. The Consensus Problem in Unreliable Distributed Systems (A Brief Survey). In Fundamentals of Computation Theory, Proceedings of the 1983 International FCT-Conference, Borgholm, Sweden, August 21-27, 1983, volume 158 of Lecture Notes in Computer Science, pages 127–140. Springer, 1983.



[FS86]<a name="FS86"> </a>A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions to Identifica- tion and Signature Problems. In Advances in Cryptology - CRYPTO ’86, Santa Barbara, California, USA, 1986, Proceedings, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986.



[GHM+17]<a name="GHM17"> </a>Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. Cryptology ePrint Archive, Report 2017/454, 2017. https://eprint.iacr.org/2017/454.



[Gro21]<a name="Gro21"> </a>J. Groth. Non-interactive distributed key generation and key resharing. Cryp- tology ePrint Archive, Report 2021/339, 2021. https://ia.cr/2021/339.



[JMV01]<a name="JVM01"> </a>D. Johnson, A. Menezes, and S. A. Vanstone. The Elliptic Curve Digital Sig- nature Algorithm (ECDSA). Int. J. Inf. Sec., 1(1):36–63, 2001.



[Mer87]<a name="Mer87"> </a>R. C. Merkle. A Digital Signature Based on a Conventional Encryption Func- tion. In Advances in Cryptology - CRYPTO ’87, A Conference on the Theory and Applications of Cryptographic Techniques, Santa Barbara, California, USA, August 16-20, 1987, Proceedings, volume 293 of Lecture Notes in Computer Sci- ence, pages 369–378. Springer, 1987.



[MXC^+^16]<a name="[MXC16]"> </a>A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. The Honey Badger of BFT Protocols. In E. R. Weippl, S. Katzenbeisser, C. Kruegel, A. C. My- ers, and S. Halevi, editors, Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016, pages 31–42. ACM, 2016.



[Nak08]<a name="Nak08"> </a>S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008. https: //bitcoin.org/bitcoin.pdf.



[PS18]<a name="PS18"> </a>R. Pass and E. Shi. Thunderella: Blockchains with Optimistic Instant Con- firmation. In J. B. Nielsen and V. Rijmen, editors, Advances in Cryptology - EUROCRYPT 2018 - 37th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II, volume 10821 of Lecture Notes in Computer Science, pages 3–33. Springer, 2018.



[PSS17]<a name="PSS17"> </a>R. Pass, L. Seeman, and A. Shelat. Analysis of the Blockchain Protocol in Asynchronous Networks. In Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryp- tographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II, volume 10211 of Lecture Notes in Computer Science, pages 643–673, 2017.



[Sch90]<a name="[Sch90]"> </a>F. B. Schneider. Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial. ACM Comput. Surv., 22(4):299–319, 1990.

